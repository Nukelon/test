<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2048 游戏</title>
  <style>
    :root {
      --bg: #f7f1e3;
      --grid: #bbada0;
      --tile: #cdc1b4;
      --font: 'Helvetica Neue', Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background: var(--bg);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
      color: #776e65;
    }

    .container {
      width: min(520px, 95vw);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      gap: 12px;
      flex-wrap: wrap;
    }

    h1 {
      font-size: 48px;
      margin: 0;
    }

    .scores {
      display: flex;
      gap: 8px;
    }

    .score-box {
      background: #bbada0;
      color: #fff;
      padding: 10px 14px;
      border-radius: 8px;
      text-align: center;
      min-width: 80px;
    }

    .score-box .label {
      display: block;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-box .value {
      font-size: 22px;
      font-weight: 700;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    button {
      background: #8f7a66;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 10px 12px;
      font-size: 15px;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.16);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .help {
      font-size: 15px;
      margin-bottom: 16px;
      color: #8f7a66;
    }

    .board {
      background: var(--grid);
      border-radius: 12px;
      padding: 12px;
      position: relative;
      aspect-ratio: 1;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 12px;
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    }

    .cell {
      background: var(--tile);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      font-weight: 700;
      color: #776e65;
      transition: transform 120ms ease, background-color 120ms ease, color 120ms ease;
      user-select: none;
    }

    .cell[data-value="0"] {
      background: rgba(238, 228, 218, 0.35);
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      font-size: 32px;
      font-weight: 700;
      color: #776e65;
      border-radius: 12px;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 180ms ease;
    }

    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay button {
      pointer-events: auto;
    }

    .footer {
      margin-top: 12px;
      color: #8f7a66;
      font-size: 14px;
    }

    @media (max-width: 520px) {
      h1 {
        font-size: 38px;
      }

      .score-box .value {
        font-size: 18px;
      }

      .cell {
        font-size: 30px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>2048</h1>
      <div class="scores">
        <div class="score-box">
          <span class="label">分数</span>
          <span class="value" id="score">0</span>
        </div>
        <div class="score-box">
          <span class="label">最佳</span>
          <span class="value" id="best">0</span>
        </div>
      </div>
    </header>

    <div class="controls">
      <button id="newGame">重新开始</button>
      <button id="undo">撤销</button>
      <span class="help">使用方向键或滑动移动方块，合并得到 2048！</span>
    </div>

    <div class="board" id="board"></div>
    <div class="overlay" id="overlay">
      <div id="overlayText"></div>
      <button id="overlayBtn">再来一局</button>
    </div>

    <p class="footer">键盘：↑ ↓ ← →，或在触屏上滑动。达到 2048 获胜，棋盘无空位且不能移动则游戏结束。</p>
  </div>

  <script>
    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const newBtn = document.getElementById('newGame');
    const undoBtn = document.getElementById('undo');
    const overlay = document.getElementById('overlay');
    const overlayText = document.getElementById('overlayText');
    const overlayBtn = document.getElementById('overlayBtn');

    const size = 4;
    let grid = createEmpty();
    let score = 0;
    let best = Number(localStorage.getItem('best-2048') || 0);
    let history = [];

    const colors = {
      2: '#eee4da',
      4: '#ede0c8',
      8: '#f2b179',
      16: '#f59563',
      32: '#f67c5f',
      64: '#f65e3b',
      128: '#edcf72',
      256: '#edcc61',
      512: '#edc850',
      1024: '#edc53f',
      2048: '#edc22e',
      4096: '#3c3a32'
    };

    function createEmpty() {
      return Array.from({ length: size }, () => Array(size).fill(0));
    }

    function randomEmptyCell() {
      const empty = [];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (grid[r][c] === 0) empty.push([r, c]);
        }
      }
      if (empty.length === 0) return null;
      return empty[Math.floor(Math.random() * empty.length)];
    }

    function addRandomTile() {
      const pos = randomEmptyCell();
      if (!pos) return false;
      const [r, c] = pos;
      grid[r][c] = Math.random() < 0.9 ? 2 : 4;
      return true;
    }

    function saveHistory() {
      history.push({
        grid: grid.map(row => [...row]),
        score
      });
      if (history.length > 20) history.shift();
    }

    function updateBest() {
      if (score > best) {
        best = score;
        localStorage.setItem('best-2048', best);
      }
    }

    function render() {
      scoreEl.textContent = score;
      updateBest();
      bestEl.textContent = best;
      boardEl.innerHTML = '';

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const value = grid[r][c];
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.value = value;
          if (value) {
            cell.textContent = value;
            cell.style.backgroundColor = colors[value] || '#3c3a32';
            cell.style.color = value >= 8 ? '#f9f6f2' : '#776e65';
          }
          boardEl.appendChild(cell);
        }
      }
    }

    function slide(row) {
      const filtered = row.filter(v => v !== 0);
      const merged = [];
      let skip = false;
      for (let i = 0; i < filtered.length; i++) {
        if (skip) {
          skip = false;
          continue;
        }
        if (filtered[i] === filtered[i + 1]) {
          const val = filtered[i] * 2;
          merged.push(val);
          score += val;
          skip = true;
        } else {
          merged.push(filtered[i]);
        }
      }
      while (merged.length < size) merged.push(0);
      return merged;
    }

    function transpose(matrix) {
      return matrix[0].map((_, i) => matrix.map(row => row[i]));
    }

    function reverse(matrix) {
      return matrix.map(row => [...row].reverse());
    }

    function move(direction) {
      const prev = grid.map(row => [...row]);
      saveHistory();

      switch (direction) {
        case 'left':
          grid = grid.map(slide);
          break;
        case 'right':
          grid = reverse(grid).map(slide);
          grid = reverse(grid);
          break;
        case 'up':
          grid = transpose(grid);
          grid = grid.map(slide);
          grid = transpose(grid);
          break;
        case 'down':
          grid = transpose(grid);
          grid = reverse(grid).map(slide);
          grid = reverse(grid);
          grid = transpose(grid);
          break;
      }

      if (!changed(prev, grid)) {
        history.pop();
        return;
      }

      addRandomTile();
      render();
      checkGameState();
    }

    function changed(prev, next) {
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (prev[r][c] !== next[r][c]) return true;
        }
      }
      return false;
    }

    function hasMoves() {
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const value = grid[r][c];
          if (value === 0) return true;
          if (r < size - 1 && value === grid[r + 1][c]) return true;
          if (c < size - 1 && value === grid[r][c + 1]) return true;
        }
      }
      return false;
    }

    function checkGameState() {
      const flat = grid.flat();
      if (flat.includes(2048)) {
        showOverlay('你赢了！');
      } else if (!hasMoves()) {
        showOverlay('游戏结束');
      }
    }

    function showOverlay(text) {
      overlayText.textContent = text;
      overlay.classList.add('show');
    }

    function hideOverlay() {
      overlay.classList.remove('show');
    }

    function undo() {
      const last = history.pop();
      if (!last) return;
      grid = last.grid.map(row => [...row]);
      score = last.score;
      render();
      hideOverlay();
    }

    function reset() {
      grid = createEmpty();
      score = 0;
      history = [];
      hideOverlay();
      addRandomTile();
      addRandomTile();
      render();
    }

    function handleKey(e) {
      const keyMap = {
        ArrowLeft: 'left',
        ArrowRight: 'right',
        ArrowUp: 'up',
        ArrowDown: 'down',
        a: 'left',
        d: 'right',
        w: 'up',
        s: 'down'
      };
      const dir = keyMap[e.key];
      if (dir) {
        e.preventDefault();
        move(dir);
      }
    }

    let touchStart = null;

    function handleTouchStart(e) {
      const touch = e.touches[0];
      touchStart = { x: touch.clientX, y: touch.clientY };
    }

    function handleTouchEnd(e) {
      if (!touchStart) return;
      const touch = e.changedTouches[0];
      const dx = touch.clientX - touchStart.x;
      const dy = touch.clientY - touchStart.y;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const threshold = 30;

      if (Math.max(absX, absY) < threshold) return;
      if (absX > absY) {
        move(dx > 0 ? 'right' : 'left');
      } else {
        move(dy > 0 ? 'down' : 'up');
      }
      touchStart = null;
    }

    newBtn.addEventListener('click', reset);
    undoBtn.addEventListener('click', undo);
    overlayBtn.addEventListener('click', reset);
    document.addEventListener('keydown', handleKey);
    boardEl.addEventListener('touchstart', handleTouchStart, { passive: true });
    boardEl.addEventListener('touchend', handleTouchEnd);

    reset();
  </script>
</body>
</html>
