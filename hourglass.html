<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>3D 物理沙漏示例</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(ellipse at top, #1e293b 0%, #020617 60%, #000000 100%);
      color: #e5e7eb;
    }

    #app {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .ui-overlay {
      position: absolute;
      left: 24px;
      bottom: 24px;
      padding: 12px 16px;
      background: rgba(15, 23, 42, 0.7);
      border-radius: 10px;
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.35);
      pointer-events: none;
    }

    .ui-overlay h1 {
      margin: 0 0 4px;
      font-size: 14px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .ui-overlay p {
      margin: 0;
      font-size: 12px;
      color: #9ca3af;
      line-height: 1.6;
    }
  </style>
</head>
<body>
<div id="app">
  <div class="ui-overlay">
    <h1>3D Hourglass</h1>
    <p>
      鼠标左键拖动：旋转视角<br/>
      鼠标滚轮：缩放<br/>
      鼠标右键拖动：平移
    </p>
  </div>
</div>

<!-- Three.js 核心库 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.150.1/three.min.js"></script>
<!-- OrbitControls 轨道控制器（支持任意角度旋转） -->
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
<!-- Cannon.js 物理引擎 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
  // ========= 基本场景搭建 =========
  const container = document.getElementById('app');

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x020617, 0.25);

  const camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(2.5, 1.8, 3.2);

  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.physicallyCorrectLights = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  // 轨道控制器（任意角度旋转）
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 1.5;
  controls.maxDistance = 7;
  controls.target.set(0, 0.9, 0);

  // ========= 灯光 =========
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
  mainLight.position.set(4, 6, 3);
  mainLight.castShadow = true;
  mainLight.shadow.mapSize.width = 1024;
  mainLight.shadow.mapSize.height = 1024;
  scene.add(mainLight);

  const backLight = new THREE.DirectionalLight(0x88b4ff, 0.4);
  backLight.position.set(-3, 3, -4);
  scene.add(backLight);

  // ========= 地台 / 环境 =========
  const floorGeometry = new THREE.CylinderGeometry(1.2, 1.4, 0.2, 48);
  const floorMaterial = new THREE.MeshStandardMaterial({
    color: 0x0b1120,
    roughness: 0.6,
    metalness: 0.2
  });
  const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
  floorMesh.receiveShadow = true;
  floorMesh.position.y = -0.05;
  scene.add(floorMesh);

  // ========= 物理世界 =========
  const world = new CANNON.World();
  world.gravity.set(0, -9.82, 0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 10;

  const sandMaterialPhys = new CANNON.Material('sand');
  const wallMaterialPhys = new CANNON.Material('wall');

  const sandWallContact = new CANNON.ContactMaterial(
    sandMaterialPhys,
    wallMaterialPhys,
    {
      friction: 0.3,
      restitution: 0.1
    }
  );
  world.addContactMaterial(sandWallContact);

  // 物理地面（与 Three 里的地台对齐）
  const groundShape = new CANNON.Box(new CANNON.Vec3(0.7, 0.05, 0.7));
  const groundBody = new CANNON.Body({
    mass: 0,
    shape: groundShape,
    material: wallMaterialPhys
  });
  groundBody.position.set(0, 0.05, 0);
  world.addBody(groundBody);

  // 四周围墙，让沙粒不会飞出玻璃太远（简单的长方体围墙）
  const wallHeight = 2.2;
  const wallThickness = 0.05;
  const wallHalfSize = 0.6;

  function createWallBox(halfX, halfY, halfZ, x, y, z) {
    const shape = new CANNON.Box(new CANNON.Vec3(halfX, halfY, halfZ));
    const body = new CANNON.Body({
      mass: 0,
      shape: shape,
      material: wallMaterialPhys
    });
    body.position.set(x, y, z);
    world.addBody(body);
  }

  // 前后墙
  createWallBox(wallHalfSize, wallHeight * 0.5, wallThickness, 0, wallHeight * 0.5, -wallHalfSize);
  createWallBox(wallHalfSize, wallHeight * 0.5, wallThickness, 0, wallHeight * 0.5, wallHalfSize);
  // 左右墙
  createWallBox(wallThickness, wallHeight * 0.5, wallHalfSize, -wallHalfSize, wallHeight * 0.5, 0);
  createWallBox(wallThickness, wallHeight * 0.5, wallHalfSize, wallHalfSize, wallHeight * 0.5, 0);

  // ========= 精致沙漏模型（仅视觉） =========
  // 使用 LatheGeometry 做玻璃的双锥形轮廓
  function createGlassHourglass() {
    const points = [];
    const totalHeight = 1.8;
    const halfHeight = totalHeight / 2;
    const neckRadius = 0.08;
    const bulbRadius = 0.45;
    const baseRadius = 0.22;

    // 从底部到顶部的截面轮廓（左侧半径-高度曲线）
    points.push(new THREE.Vector2(baseRadius, -halfHeight));    // 底部边缘
    points.push(new THREE.Vector2(bulbRadius, -halfHeight + 0.3));
    points.push(new THREE.Vector2(neckRadius * 1.1, -0.12));    // 下方收缩
    points.push(new THREE.Vector2(neckRadius, 0));              // 中间窄口
    points.push(new THREE.Vector2(neckRadius * 1.1, 0.12));     // 上方扩散
    points.push(new THREE.Vector2(bulbRadius, halfHeight - 0.3));
    points.push(new THREE.Vector2(baseRadius, halfHeight));     // 顶部边缘

    const glassGeom = new THREE.LatheGeometry(points, 64);
    const glassMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      roughness: 0.08,
      metalness: 0.0,
      transmission: 0.97,   // 透光
      opacity: 1.0,
      transparent: true,
      thickness: 0.6,
      envMapIntensity: 1.2,
      clearcoat: 1.0,
      clearcoatRoughness: 0.15
    });

    const glassMesh = new THREE.Mesh(glassGeom, glassMat);
    glassMesh.position.y = 0.95;
    glassMesh.castShadow = true;
    scene.add(glassMesh);

    // 上下金属圈
    const ringGeom = new THREE.TorusGeometry(bulbRadius * 1.02, 0.02, 16, 64);
    const ringMat = new THREE.MeshStandardMaterial({
      color: 0xfacc15,
      metalness: 0.9,
      roughness: 0.25
    });

    const topRing = new THREE.Mesh(ringGeom, ringMat);
    topRing.rotation.x = Math.PI / 2;
    topRing.position.y = glassMesh.position.y + halfHeight;
    scene.add(topRing);

    const bottomRing = topRing.clone();
    bottomRing.position.y = glassMesh.position.y - halfHeight;
    scene.add(bottomRing);

    // 四根立柱
    const pillarGeom = new THREE.CylinderGeometry(0.03, 0.03, totalHeight + 0.4, 24);
    const pillarMat = new THREE.MeshStandardMaterial({
      color: 0x9ca3af,
      metalness: 0.7,
      roughness: 0.3
    });

    const pillarRadius = bulbRadius * 1.1;
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * Math.PI * 2;
      const pillar = new THREE.Mesh(pillarGeom, pillarMat);
      pillar.position.set(
        Math.cos(angle) * pillarRadius,
        glassMesh.position.y,
        Math.sin(angle) * pillarRadius
      );
      pillar.castShadow = true;
      scene.add(pillar);
    }

    // 顶盖与底座的小圆盘
    const capGeom = new THREE.CylinderGeometry(0.6, 0.6, 0.06, 48);
    const capMat = new THREE.MeshStandardMaterial({
      color: 0x111827,
      metalness: 0.4,
      roughness: 0.5
    });

    const topCap = new THREE.Mesh(capGeom, capMat);
    topCap.position.y = topRing.position.y + 0.06;
    topCap.receiveShadow = true;
    topCap.castShadow = true;
    scene.add(topCap);

    const bottomCap = new THREE.Mesh(capGeom, capMat);
    bottomCap.position.y = bottomRing.position.y - 0.06;
    bottomCap.receiveShadow = true;
    bottomCap.castShadow = true;
    scene.add(bottomCap);
  }

  createGlassHourglass();

  // ========= 沙粒（Three + Cannon 绑定） =========
  const sandCount = 260;
  const sandRadius = 0.03;
  const sandBodies = [];

  const sandGeometry = new THREE.SphereGeometry(sandRadius, 14, 14);
  const sandMaterial = new THREE.MeshStandardMaterial({
    color: 0xfbbf24,
    roughness: 0.5,
    metalness: 0.1
  });

  const sandMesh = new THREE.InstancedMesh(sandGeometry, sandMaterial, sandCount);
  sandMesh.castShadow = true;
  sandMesh.receiveShadow = true;
  scene.add(sandMesh);

  const tempMatrix = new THREE.Matrix4();
  const tempPosition = new THREE.Vector3();

  function initSand() {
    for (let i = 0; i < sandCount; i++) {
      const body = new CANNON.Body({
        mass: 0.02,
        shape: new CANNON.Sphere(sandRadius),
        material: sandMaterialPhys
      });

      // 将沙粒初始随机放在上半部分的“沙堆”位置
      const angle = Math.random() * Math.PI * 2;
      const r = 0.15 * Math.sqrt(Math.random());
      const x = Math.cos(angle) * r;
      const z = Math.sin(angle) * r;
      const y = 1.4 + Math.random() * 0.3; // 上半球区域

      body.position.set(x, y, z);
      body.linearDamping = 0.01;
      body.angularDamping = 0.01;

      sandBodies.push(body);
      world.addBody(body);

      tempMatrix.identity().setPosition(x, y, z);
      sandMesh.setMatrixAt(i, tempMatrix);
    }
    sandMesh.instanceMatrix.needsUpdate = true;
  }

  initSand();

  // ========= 动画循环 =========
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    const fixedTimeStep = 1 / 60;
    const maxSubSteps = 3;

    world.step(fixedTimeStep, delta, maxSubSteps);

    // 同步物理沙粒的位置信息到 Three.js
    for (let i = 0; i < sandCount; i++) {
      const body = sandBodies[i];
      const p = body.position;

      // 简单的越界重生逻辑：如果沙粒掉得太远，就重新放回顶部
      if (p.y < -1 || Math.abs(p.x) > 1.5 || Math.abs(p.z) > 1.5) {
        const angle = Math.random() * Math.PI * 2;
        const r = 0.15 * Math.sqrt(Math.random());
        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;
        const y = 1.4 + Math.random() * 0.3;

        body.position.set(x, y, z);
        body.velocity.set(0, 0, 0);
        body.angularVelocity.set(0, 0, 0);
      }

      tempPosition.set(p.x, p.y, p.z);
      tempMatrix.identity().setPosition(tempPosition);
      sandMesh.setMatrixAt(i, tempMatrix);
    }
    sandMesh.instanceMatrix.needsUpdate = true;

    controls.update();
    renderer.render(scene, camera);
  }

  animate();

  // ========= 自适应窗口大小 =========
  function onWindowResize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }

  window.addEventListener('resize', onWindowResize);
</script>
</body>
</html>
