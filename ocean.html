<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>海浪模拟</title>
  <style>
    :root{
      --glass: rgba(10, 22, 30, 0.42);
      --glass2: rgba(10, 22, 30, 0.22);
      --brd: rgba(255,255,255,0.12);
      --txt: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --accent: rgba(120, 210, 255, 0.95);
      --shadow: rgba(0,0,0,0.38);
    }
    html,body{
      height:100%;
      margin:0;
      overflow:hidden;
      background: radial-gradient(1200px 700px at 70% 20%, #1a5466 0%, #0a2230 45%, #06161f 100%);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC","Microsoft YaHei", Arial;
      color: var(--txt);
    }
    #app{ position:fixed; inset:0; }
    canvas{ display:block; width:100%; height:100%; }

    .panel{
      position:fixed;
      left:16px; top:16px;
      width:min(400px, calc(100% - 32px));
      padding:14px 14px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03)) , var(--glass);
      border: 1px solid var(--brd);
      border-radius: 16px;
      box-shadow: 0 18px 44px var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      user-select:none;
    }
    .title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .title h1{
      font-size:15px;
      letter-spacing:0.8px;
      margin:0;
      font-weight:720;
    }
    .chip{
      font-size:12px;
      color: rgba(255,255,255,0.78);
      padding:6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
    }
    .row{
      display:grid;
      grid-template-columns: 92px 1fr 76px;
      align-items:center;
      gap:10px;
      padding:9px 0;
    }
    .label{ font-size:13px; color: var(--muted); }
    input[type="range"]{ width:100%; accent-color: var(--accent); }
    .val{
      font-variant-numeric: tabular-nums;
      font-size:13px;
      text-align:right;
      color: rgba(255,255,255,0.90);
    }
    .footer{
      margin-top:10px;
      padding-top:10px;
      border-top: 1px solid rgba(255,255,255,0.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .btns{ display:flex; gap:8px; align-items:center; }
    .btn{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.90);
      padding:8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-size:12px;
      transition: transform 140ms ease, background 140ms ease;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); transform: translateY(-1px); }
    .note{
      font-size:12px;
      color: rgba(255,255,255,0.62);
      line-height:1.35;
    }
    .badge{
      position: fixed;
      right: 14px; bottom: 14px;
      padding: 9px 11px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03)), var(--glass2);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 14px 34px rgba(0,0,0,0.26);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: rgba(255,255,255,0.70);
      font-size: 12px;
      letter-spacing: 0.3px;
    }
  </style>
</head>

<body>
  <div id="app"></div>

  <div class="panel" aria-label="控制面板">
    <div class="title">
      <h1>海浪模拟</h1>
      <div class="chip">精致后期 · Bloom（已修复泛滥）</div>
    </div>

    <div class="row">
      <div class="label">风速</div>
      <input id="wind" type="range" min="0" max="30" step="0.1" value="8" />
      <div class="val" id="windVal">8.0</div>
    </div>

    <div class="row">
      <div class="label">浪高</div>
      <input id="height" type="range" min="0" max="6" step="0.01" value="1.4" />
      <div class="val" id="heightVal">1.40</div>
    </div>

    <div class="row">
      <div class="label">光照</div>
      <input id="light" type="range" min="0.2" max="2.2" step="0.01" value="1.0" />
      <div class="val" id="lightVal">1.00</div>
    </div>

    <div class="footer">
      <div class="btns">
        <button class="btn" id="reset">恢复默认</button>
        <button class="btn" id="cinema">电影感</button>
      </div>
      <div class="note">如果你仍觉得“太平”，把浪高调到 1.8–2.6；要更宁静，把风速 6–10、浪高 0.9–1.6。</div>
    </div>
  </div>

  <div class="badge">Microfacet BRDF · fbm Foam · Half-Res Bloom</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (function(){
    if(!window.THREE){
      document.body.innerHTML = "<div style='padding:18px;color:#fff;font-family:system-ui'>THREE 未加载：请确认 CDN 可访问或未被拦截。</div>";
      return;
    }
    const THREE = window.THREE;
    const app = document.getElementById("app");

    // ---------- Renderer ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // 关键：避免“渲染目标里先 ACES，再合成里再 film curve”导致细节被洗掉
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.autoClear = true;
    app.appendChild(renderer.domElement);

    // ---------- Scene / Camera ----------
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x06161f, 0.010);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 3000);
    // 更掠射、更“见波纹”的构图
    camera.position.set(0, 18, 84);
    camera.lookAt(0, 0, -40);

    // ---------- Sky (gradient + sun disk) ----------
    const skyUniforms = {
      uTop:    { value: new THREE.Color("#2a7d8e") },
      uBottom: { value: new THREE.Color("#06161f") },
      uSunDir: { value: new THREE.Vector3(0.35, 0.72, 0.55).normalize() },
      uSunCol: { value: new THREE.Color("#ffe8c7") },
      uSunStrength: { value: 1.0 }
    };

    const sky = new THREE.Mesh(
      new THREE.SphereGeometry(1600, 64, 32),
      new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: skyUniforms,
        vertexShader: `
          varying vec3 vPos;
          void main(){
            vec4 wp = modelMatrix * vec4(position,1.0);
            vPos = wp.xyz;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec3 vPos;
          uniform vec3 uTop;
          uniform vec3 uBottom;
          uniform vec3 uSunDir;
          uniform vec3 uSunCol;
          uniform float uSunStrength;

          void main(){
            vec3 d = normalize(vPos);
            float h = clamp(d.y*0.5+0.5, 0.0, 1.0);
            vec3 col = mix(uBottom, uTop, pow(h, 1.10));

            float sun = max(dot(d, normalize(uSunDir)), 0.0);
            float disk = smoothstep(0.99925, 0.99995, sun);
            float halo = smoothstep(0.985, 0.99925, sun) * 0.16;
            col += uSunCol * (disk*1.25 + halo) * uSunStrength;

            col = mix(col, vec3(dot(col, vec3(0.299,0.587,0.114))), 0.05);
            gl_FragColor = vec4(col, 1.0);
          }
        `
      })
    );
    scene.add(sky);

    // ---------- Lights ----------
    const ambient = new THREE.AmbientLight(0xffffff, 0.30);
    scene.add(ambient);

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(80, 140, 90);
    scene.add(sun);

    // ---------- Ocean ----------
    const oceanUniforms = {
      uTime: { value: 0 },
      uWind: { value: 8.0 },
      uAmp:  { value: 1.4 },
      uLight: { value: 1.0 },
      uSunDir: { value: skyUniforms.uSunDir.value.clone() },
      uSkyTop: { value: skyUniforms.uTop.value.clone() },
      uSkyBottom: { value: skyUniforms.uBottom.value.clone() },
      uSunCol: { value: skyUniforms.uSunCol.value.clone() }
    };

    const oceanMat = new THREE.ShaderMaterial({
      uniforms: oceanUniforms,
      fog: true,
      vertexShader: `
        precision highp float;

        uniform float uTime;
        uniform float uWind;
        uniform float uAmp;

        varying vec3 vWorldPos;
        varying vec3 vNormalW;
        varying float vFoam;
        varying float vCrest;

        vec3 gerstner(vec2 xz, vec2 dir, float wl, float steep, float spd, float amp, out float crest){
          float k = 6.28318530718 / wl;
          float c = sqrt(9.8 / k) * spd;
          float f = k * (dot(dir, xz) - c * uTime);
          float a = amp / k;

          float s = sin(f);
          float co = cos(f);

          crest = pow(max(0.0, s*0.5 + 0.5), 3.0);

          float q = steep / (k * a * 6.0 + 1.0);
          return vec3(q * a * dir.x * co, a * s, q * a * dir.y * co);
        }

        // 不用数组初始化（更稳），明确叠加谱
        vec3 oceanDisp(vec2 xz, out float crestSum){
          float wind = max(uWind, 0.0);
          float energy = mix(0.30, 1.20, clamp(wind/22.0, 0.0, 1.0));
          float A = uAmp * energy;

          float ws = 1.0 + wind * 0.018;

          vec3 d = vec3(0.0);
          crestSum = 0.0;
          float c;

          vec2 d0 = normalize(vec2(0.86, 0.52));
          vec2 d1 = normalize(vec2(0.44, 0.90));
          vec2 d2 = normalize(vec2(-0.25, 0.97));
          vec2 d3 = normalize(vec2(0.98, -0.20));
          vec2 d4 = normalize(vec2(-0.75, -0.66));
          vec2 d5 = normalize(vec2(0.18, -0.98));
          vec2 d6 = normalize(vec2(0.66, -0.75));
          vec2 d7 = normalize(vec2(-0.98, 0.22));

          d += gerstner(xz, d0,  44.0, 0.95, 1.02*ws, A*1.00, c); crestSum += c*0.40;
          d += gerstner(xz, d1,  30.0, 0.92, 1.10*ws, A*0.62, c); crestSum += c*0.26;
          d += gerstner(xz, d2,  20.0, 0.88, 1.18*ws, A*0.44, c); crestSum += c*0.18;
          d += gerstner(xz, d3,  14.0, 0.82, 1.26*ws, A*0.30, c); crestSum += c*0.09;
          d += gerstner(xz, d4,  10.5, 0.76, 1.34*ws, A*0.22, c); crestSum += c*0.05;
          d += gerstner(xz, d5,   7.8, 0.68, 1.42*ws, A*0.16, c); crestSum += c*0.03;
          d += gerstner(xz, d6,   5.6, 0.60, 1.52*ws, A*0.11, c); crestSum += c*0.02;
          d += gerstner(xz, d7,   4.0, 0.52, 1.62*ws, A*0.07, c); crestSum += c*0.01;

          // 细碎波（强化“高光碎裂”）
          vec2 d8  = normalize(vec2(0.90, 0.44));
          vec2 d9  = normalize(vec2(-0.52, 0.86));
          vec2 d10 = normalize(vec2(0.12, 0.99));
          d += gerstner(xz*1.6, d8,   2.6, 0.48, 1.78*ws, A*0.050, c); crestSum += c*0.015;
          d += gerstner(xz*2.1, d9,   1.9, 0.44, 1.88*ws, A*0.040, c); crestSum += c*0.012;
          d += gerstner(xz*2.7, d10,  1.4, 0.40, 1.98*ws, A*0.030, c); crestSum += c*0.010;

          crestSum = clamp(crestSum, 0.0, 1.0);
          return d;
        }

        void main(){
          vec3 pos = position;

          float crest;
          vec3 disp = oceanDisp(pos.xz, crest);
          pos += disp;

          // 法线差分：更细腻
          float eps = 0.10;
          float c1; float c2;
          vec3 dispX = oceanDisp(position.xz + vec2(eps, 0.0), c1);
          vec3 dispZ = oceanDisp(position.xz + vec2(0.0, eps), c2);

          vec3 p  = vec3(position.x, 0.0, position.z) + disp;
          vec3 px = vec3(position.x + eps, 0.0, position.z) + dispX;
          vec3 pz = vec3(position.x, 0.0, position.z + eps) + dispZ;

          vec3 n = normalize(cross(pz - p, px - p));

          float slope = 1.0 - clamp(n.y, 0.0, 1.0);
          vFoam = clamp(crest*0.85 + slope*0.75, 0.0, 1.0);
          vCrest = crest;

          vec4 wp = modelMatrix * vec4(pos,1.0);
          vWorldPos = wp.xyz;
          vNormalW = normalize(mat3(modelMatrix) * n);

          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: `
        precision highp float;

        uniform float uLight;
        uniform float uWind;
        uniform vec3 uSunDir;
        uniform vec3 uSkyTop;
        uniform vec3 uSkyBottom;
        uniform vec3 uSunCol;

        varying vec3 vWorldPos;
        varying vec3 vNormalW;
        varying float vFoam;
        varying float vCrest;

        float saturate(float x){ return clamp(x, 0.0, 1.0); }

        // ---- fbm noise ----
        float hash(vec2 p){
          p = fract(p * vec2(123.34, 456.21));
          p += dot(p, p + 34.345);
          return fract(p.x * p.y);
        }
        float noise(vec2 p){
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0,0.0));
          float c = hash(i + vec2(0.0,1.0));
          float d = hash(i + vec2(1.0,1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
        }
        float fbm(vec2 p){
          float v = 0.0;
          float a = 0.5;
          mat2 m = mat2(1.6, -1.2, 1.2, 1.6);
          for(int i=0;i<6;i++){
            v += a * noise(p);
            p = m * p;
            a *= 0.52;
          }
          return v;
        }

        // ---- GGX microfacet ----
        vec3 fresnelSchlick(float cosTheta, vec3 F0){
          return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
        }
        float D_GGX(float NoH, float rough){
          float a  = rough*rough;
          float a2 = a*a;
          float d = (NoH*NoH)*(a2 - 1.0) + 1.0;
          return a2 / max(3.14159265 * d*d, 1e-6);
        }
        float V_SmithGGXCorrelated(float NoV, float NoL, float rough){
          float a = rough*rough;
          float gv = NoL * sqrt(max(NoV*(NoV*(1.0-a)+a), 1e-6));
          float gl = NoV * sqrt(max(NoL*(NoL*(1.0-a)+a), 1e-6));
          return 0.5 / max(gv + gl, 1e-6);
        }

        vec3 sampleSky(vec3 dir){
          float t = saturate(dir.y*0.5 + 0.5);
          vec3 col = mix(uSkyBottom, uSkyTop, pow(t, 1.10));
          float sun = max(dot(normalize(dir), normalize(uSunDir)), 0.0);
          float disk = smoothstep(0.99935, 0.99996, sun);
          float halo = smoothstep(0.987, 0.99935, sun) * 0.10;
          col += uSunCol * (disk*1.05 + halo) * uLight;
          return col;
        }

        void main(){
          vec3 N = normalize(vNormalW);
          vec3 V = normalize(cameraPosition - vWorldPos);
          vec3 L = normalize(uSunDir);
          vec3 H = normalize(V + L);

          float NoV = saturate(dot(N, V));
          float NoL = saturate(dot(N, L));
          float NoH = saturate(dot(N, H));
          float VoH = saturate(dot(V, H));

          float slope = 1.0 - saturate(N.y);
          float windR = saturate(uWind / 22.0);
          float rough = clamp(0.05 + 0.16*windR + 0.10*slope, 0.04, 0.32);

          vec3 F0 = vec3(0.02, 0.028, 0.035);

          float D = D_GGX(NoH, rough);
          float Vis = V_SmithGGXCorrelated(NoV, NoL, rough);
          vec3  F = fresnelSchlick(VoH, F0);
          vec3  spec = (D * Vis) * F * NoL;

          vec3 R = reflect(-V, N);
          vec3 skyRefl = sampleSky(R);

          float dist = length(cameraPosition - vWorldPos);
          float depthApprox = saturate(dist / 520.0);
          vec3 deepCol = vec3(0.015, 0.09, 0.13);
          vec3 shallowCol = vec3(0.045, 0.35, 0.40);
          vec3 waterCol = mix(shallowCol, deepCol, pow(depthApprox, 1.25));

          float fres = pow(1.0 - NoV, 5.0);
          vec3 col = mix(waterCol, skyRefl, saturate(0.20 + 0.90*fres));

          // 让“起伏”更可见：补一点克制的体积感
          col += waterCol * (0.05 + 0.10*NoL) * uLight;

          // 镜面高光是水面的灵魂
          col += spec * (1.10 + 1.10*uLight);

          // 泡沫：浪尖+斜率+fbm 破碎
          float n = fbm(vWorldPos.xz * 0.12 + vec2(0.0, 0.25));
          float foamMask = smoothstep(0.62, 0.96, vFoam) * (0.55 + 0.45*n);
          float crestBoost = smoothstep(0.72, 1.0, vCrest) * 0.40;
          vec3 foamCol = vec3(0.90, 0.97, 1.00) * (1.0 + crestBoost);
          col = mix(col, foamCol, foamMask * 0.70);

          // 微闪烁（克制）
          float glitter = pow(saturate(dot(reflect(-L, N), V)), 90.0);
          col += uSunCol * glitter * (0.08 + 0.14*(1.0-rough)) * uLight;

          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    // 海面几何（精致优先）
    const oceanSize = 2000;
    const oceanSeg  = 700; // 极重：你说不必在意性能
    const oceanGeo = new THREE.PlaneGeometry(oceanSize, oceanSize, oceanSeg, oceanSeg);
    oceanGeo.rotateX(-Math.PI/2);
    const ocean = new THREE.Mesh(oceanGeo, oceanMat);
    ocean.frustumCulled = false;
    scene.add(ocean);

    // ---------- Post: Half-Res Bloom + Composite ----------
    const rtParams = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      type: THREE.UnsignedByteType,
      depthBuffer: true,
      stencilBuffer: false
    };

    let rtScene = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);

    function bloomSize(){
      const w = Math.max(1, Math.floor(window.innerWidth  * 0.5));
      const h = Math.max(1, Math.floor(window.innerHeight * 0.5));
      return {w,h};
    }
    let bs = bloomSize();
    let rtBright = new THREE.WebGLRenderTarget(bs.w, bs.h, rtParams);
    let rtBlur1  = new THREE.WebGLRenderTarget(bs.w, bs.h, rtParams);
    let rtBlur2  = new THREE.WebGLRenderTarget(bs.w, bs.h, rtParams);

    const postScene = new THREE.Scene();
    const postCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
    const quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial());
    postScene.add(quad);

    const brightMat = new THREE.ShaderMaterial({
      uniforms: {
        tScene: { value: null },
        uThreshold: { value: 1.10 },  // 关键：提高阈值，避免全屏泛滥
        uKnee: { value: 0.10 }        // 更小膝区，减少“雾化”
      },
      vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position.xy,0.0,1.0); }`,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D tScene;
        uniform float uThreshold;
        uniform float uKnee;

        float luminance(vec3 c){ return dot(c, vec3(0.2126, 0.7152, 0.0722)); }

        void main(){
          vec3 c = texture2D(tScene, vUv).rgb;
          float l = luminance(c);

          float t = uThreshold;
          float k = max(uKnee, 1e-6);

          // soft threshold：只有接近/超过阈值才有 bloom
          float soft = clamp((l - t + k) / (2.0*k), 0.0, 1.0);
          soft = soft*soft*(3.0-2.0*soft);

          float w = max(l - t, 0.0) + soft * k;
          vec3 outc = (l > 1e-6) ? c * (w / l) : vec3(0.0);

          gl_FragColor = vec4(outc, 1.0);
        }
      `
    });

    const blurMat = new THREE.ShaderMaterial({
      uniforms: {
        tInput: { value: null },
        uTexel: { value: new THREE.Vector2(1/bs.w, 1/bs.h) },
        uDir: { value: new THREE.Vector2(1,0) }
      },
      vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position.xy,0.0,1.0); }`,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D tInput;
        uniform vec2 uTexel;
        uniform vec2 uDir;

        void main(){
          vec2 d = uTexel * uDir;
          vec3 c = vec3(0.0);
          c += texture2D(tInput, vUv - 4.0*d).rgb * 0.051;
          c += texture2D(tInput, vUv - 3.0*d).rgb * 0.0918;
          c += texture2D(tInput, vUv - 2.0*d).rgb * 0.12245;
          c += texture2D(tInput, vUv - 1.0*d).rgb * 0.1531;
          c += texture2D(tInput, vUv        ).rgb * 0.1633;
          c += texture2D(tInput, vUv + 1.0*d).rgb * 0.1531;
          c += texture2D(tInput, vUv + 2.0*d).rgb * 0.12245;
          c += texture2D(tInput, vUv + 3.0*d).rgb * 0.0918;
          c += texture2D(tInput, vUv + 4.0*d).rgb * 0.051;
          gl_FragColor = vec4(c, 1.0);
        }
      `
    });

    const compositeMat = new THREE.ShaderMaterial({
      uniforms: {
        tScene: { value: null },
        tBloom: { value: null },
        uBloomStrength: { value: 0.38 }, // 关键：默认更克制
        uVignette: { value: 0.42 },
        uChromAb: { value: 0.0016 },
        uContrast: { value: 1.06 },
        uLift: { value: 0.010 },
        uGamma: { value: 2.2 } // 输出到 sRGB 前用 1/2.2
      },
      vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position.xy,0.0,1.0); }`,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D tScene;
        uniform sampler2D tBloom;
        uniform float uBloomStrength;
        uniform float uVignette;
        uniform float uChromAb;
        uniform float uContrast;
        uniform float uLift;
        uniform float uGamma;

        vec3 filmCurve(vec3 x){
          x = max(x, vec3(0.0));
          x = (x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14);
          return x;
        }

        void main(){
          vec2 c = vUv - 0.5;
          vec2 off = c * uChromAb;

          float r = texture2D(tScene, vUv + off).r;
          float g = texture2D(tScene, vUv).g;
          float b = texture2D(tScene, vUv - off).b;
          vec3 sceneCol = vec3(r,g,b);

          vec3 bloom = texture2D(tBloom, vUv).rgb;
          vec3 col = sceneCol + bloom * uBloomStrength;

          float v = 1.0 - smoothstep(0.08, 0.85, dot(c,c));
          col *= mix(1.0, v, uVignette);

          col = (col - 0.5) * uContrast + 0.5;
          col += uLift;

          // 只在最终做一次“胶片曲线”= tone mapping
          col = filmCurve(col);

          // gamma to sRGB-ish
          col = pow(max(col, vec3(0.0)), vec3(1.0 / max(uGamma, 0.001)));

          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    function pass(material, target){
      quad.material = material;
      renderer.setRenderTarget(target);
      renderer.render(postScene, postCam);
      renderer.setRenderTarget(null);
    }

    // ---------- UI ----------
    const $wind = document.getElementById("wind");
    const $height = document.getElementById("height");
    const $light = document.getElementById("light");
    const $windVal = document.getElementById("windVal");
    const $heightVal = document.getElementById("heightVal");
    const $lightVal = document.getElementById("lightVal");
    const $reset = document.getElementById("reset");
    const $cinema = document.getElementById("cinema");

    function applyParams(){
      const w = parseFloat($wind.value);
      const h = parseFloat($height.value);
      const li = parseFloat($light.value);

      $windVal.textContent = w.toFixed(1);
      $heightVal.textContent = h.toFixed(2);
      $lightVal.textContent = li.toFixed(2);

      oceanUniforms.uWind.value = w;
      oceanUniforms.uAmp.value = h;
      oceanUniforms.uLight.value = li;

      sun.intensity = 0.95 * li;
      ambient.intensity = 0.22 + 0.18 * li;
      skyUniforms.uSunStrength.value = li;

      // 光照越高 bloom 稍微增强，但不让它泛滥
      compositeMat.uniforms.uBloomStrength.value = 0.34 + 0.18*(li-1.0);
      compositeMat.uniforms.uBloomStrength.value = Math.max(0.22, compositeMat.uniforms.uBloomStrength.value);

      brightMat.uniforms.uThreshold.value = 1.10 + 0.08*(1.0 - li); // 亮时略降阈值，暗时略升
      brightMat.uniforms.uKnee.value = 0.10;
    }

    $wind.addEventListener("input", applyParams);
    $height.addEventListener("input", applyParams);
    $light.addEventListener("input", applyParams);

    $reset.addEventListener("click", ()=>{
      $wind.value = "8";
      $height.value = "1.4";
      $light.value = "1.0";

      skyUniforms.uSunCol.value.set("#ffe8c7");
      oceanUniforms.uSunCol.value.copy(skyUniforms.uSunCol.value);

      compositeMat.uniforms.uVignette.value = 0.42;
      compositeMat.uniforms.uChromAb.value = 0.0016;
      compositeMat.uniforms.uContrast.value = 1.06;
      compositeMat.uniforms.uLift.value = 0.010;

      applyParams();
    });

    $cinema.addEventListener("click", ()=>{
      skyUniforms.uSunCol.value.set("#ffe1b8");
      oceanUniforms.uSunCol.value.copy(skyUniforms.uSunCol.value);

      compositeMat.uniforms.uVignette.value = 0.58;
      compositeMat.uniforms.uChromAb.value = 0.0024;
      compositeMat.uniforms.uContrast.value = 1.10;
      compositeMat.uniforms.uLift.value = 0.008;

      // 电影感：稍降阈值但不泛滥
      brightMat.uniforms.uThreshold.value = 1.02;
      compositeMat.uniforms.uBloomStrength.value = Math.max(0.30, compositeMat.uniforms.uBloomStrength.value + 0.10);

      $light.value = String(Math.min(2.2, parseFloat($light.value) + 0.12));
      applyParams();
    });

    applyParams();

    // ---------- Animation ----------
    const clock = new THREE.Clock();

    function render(){
      const t = clock.getElapsedTime();
      oceanUniforms.uTime.value = t;

      const drift = 0.06 * Math.sin(t * 0.05);
      const sunDir = new THREE.Vector3(0.35 + drift, 0.72, 0.55).normalize();
      skyUniforms.uSunDir.value.copy(sunDir);
      oceanUniforms.uSunDir.value.copy(sunDir);

      // Scene -> rtScene
      renderer.setRenderTarget(rtScene);
      renderer.clear(true,true,true);
      renderer.render(scene, camera);
      renderer.setRenderTarget(null);

      // Bright (downsample)
      brightMat.uniforms.tScene.value = rtScene.texture;
      pass(brightMat, rtBright);

      // Blur H/V（只一轮，避免“整屏雾化”）
      blurMat.uniforms.uTexel.value.set(1/rtBright.width, 1/rtBright.height);

      blurMat.uniforms.tInput.value = rtBright.texture;
      blurMat.uniforms.uDir.value.set(1,0);
      pass(blurMat, rtBlur1);

      blurMat.uniforms.tInput.value = rtBlur1.texture;
      blurMat.uniforms.uDir.value.set(0,1);
      pass(blurMat, rtBlur2);

      // Composite -> screen
      compositeMat.uniforms.tScene.value = rtScene.texture;
      compositeMat.uniforms.tBloom.value = rtBlur2.texture;

      quad.material = compositeMat;
      renderer.setRenderTarget(null);
      renderer.render(postScene, postCam);

      requestAnimationFrame(render);
    }
    render();

    // ---------- Resize ----------
    function resize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

      rtScene.setSize(window.innerWidth, window.innerHeight);

      bs = bloomSize();
      rtBright.setSize(bs.w, bs.h);
      rtBlur1.setSize(bs.w, bs.h);
      rtBlur2.setSize(bs.w, bs.h);
    }
    window.addEventListener("resize", resize);
  })();
  </script>
</body>
</html>
